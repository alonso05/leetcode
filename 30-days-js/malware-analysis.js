/* Your company is analyzing malware which targets numerical record files.
The malware uses a sliding window over the array of numbers in a file, and tries to match the following pattern:
T1, -, -, Х, -, -, -, Tr
The entire window is moved so that X' passes through all the values and is compared to the numbers at the 'TI' and 'Tr' locations, which are positioned at a constant offset to 'X'.
The malware has the following rules:
• If the value at the 'T!' or 'Tr' position of the pattern is bigger or equal to the value at the X' position, the malware replaces the value at 'X' with 0.
• If the value at the T' or 'Ti' offset is out of bounds, then the value at 'X' is only compared to the
other existing value.
• The record is processed in two stages: first, all the positions that should be set to 0 are located, using the original values for comparison. Only after all positions have been identified do they get set to 0.
For example, if the values in a record file are the following:
[1, 2, 0, 5, 0, 2, 4, 3, 3, 3]
The expected values after the malware runs are:
l1, 0, 0, 5, 0, 0, 0, 3, 3, 01
In this example, both '2's, the '4' and the last '3' were replaced by 0.
Implement the simulate function so that the malware behavior is replicated for further study. */

function simulate(entries) {
    const offsets = [-4, 4]; // offsets for T1 and Tr
    const result = [...entries]; // copy the original array
  
    // first stage: identify positions to be set to 0
    const zeros = [];
    for (let i = 0; i < entries.length; i++) {
      const x = entries[i];
      for (const offset of offsets) {
        const ti = i + offset;
        if (ti >= 0 && ti < entries.length) {
          if (entries[ti] >= x) {
            zeros.push(i);
            break;
          }
        }
      }
    }
  
    // second stage: set identified positions to 0
    for (const i of zeros) {
      result[i] = 0;
    }
  
    return result;
  }

  
  
  const records = [1, 2, 0, 5, 0, 2, 4, 3, 3, 3];
  console.log(simulate(records));
  // Expected output
  // [1, 0, 0, 5, 0, 0, 0, 3, 3, 0]